<meta>
description: Execute spec tasks using TDD methodology
argument-hint: <feature-name:$1> [task-numbers:$2]
</meta>

# 实施任务执行器

<background_information>
- **使命**: 基于已批准的规范，使用测试驱动开发方法执行实施任务
- **成功标准**:
  - 所有测试在实施代码之前编写
  - 代码通过所有测试且无回归
  - 在tasks.md中标记任务为已完成
  - 实施与设计和需求对齐
</background_information>

<instructions>
## 核心任务
使用测试驱动开发为功能 **$1** 执行实施任务。

## 执行步骤

### 步骤1：加载上下文

**读取所有必要的上下文**:
- `.cursor/ssd/specs/$1/spec.json`、`requirements.md`、`design.md`、`tasks.md`
- **整个 `.cursor/ssd/steering/` 目录**以获取完整的项目记忆

**验证批准**:
- 验证任务在spec.json中已批准（如未批准则停止，参见安全和回退）

### 步骤2：选择任务

**确定要执行的任务**:
- 如果提供了 `$2`: 执行指定的任务编号（例如，"1.1"或"1,2,3"）
- 否则: 执行所有待处理任务（tasks.md中未选中的 `- [ ]`）

### 步骤3：使用TDD执行

对于每个选定的任务，遵循Kent Beck的TDD循环：

1. **RED - 编写失败测试**:
   - 为下一个小的功能片段编写测试
   - 测试应该失败（代码尚不存在）
   - 使用描述性测试名称

2. **GREEN - 编写最小代码**:
   - 实施最简单的解决方案以使测试通过
   - 仅专注于使此测试通过
   - 避免过度工程

3. **REFACTOR - 清理**:
   - 改进代码结构和可读性
   - 删除重复
   - 在适当时应用设计模式
   - 确保重构后所有测试仍然通过

4. **VERIFY - 验证质量**:
   - 所有测试通过（新的和现有的）
   - 现有功能无回归
   - 代码覆盖率保持或提高

5. **标记完成**:
   - 在tasks.md中将复选框从 `- [ ]` 更新为 `- [x]`

## 关键约束
- **TDD强制**: 测试必须在实施代码之前编写
- **任务范围**: 仅实施特定任务所需的内容
- **测试覆盖**: 所有新代码必须有测试
- **无回归**: 现有测试必须继续通过
- **设计对齐**: 实施必须遵循design.md规范
</instructions>

## 工具指南
- **先读取**: 在实施之前加载所有上下文
- **测试优先**: 在代码之前编写测试
- 需要时使用 **WebSearch/WebFetch** 获取库文档

## 输出描述

以spec.json中指定的语言提供简要摘要：

1. **执行的任务**: 任务编号和测试结果
2. **状态**: 在tasks.md中标记的已完成任务，剩余任务计数

**格式**: 简洁（少于150个汉字）

## 安全和回退

### 错误场景

**任务未批准或缺少规范文件**:
- **停止执行**: 所有规范文件必须存在，任务必须已批准
- **建议操作**: "完成之前的阶段: `/sdd/spec-requirements`、`/sdd/spec-design`、`/sdd/spec-tasks`"

**测试失败**:
- **停止实施**: 在继续之前修复失败的测试
- **操作**: 调试并修复，然后重新运行

### 任务执行

**执行特定任务**:
- `/sdd/spec-impl $1 1.1` - 单个任务
- `/sdd/spec-impl $1 1,2,3` - 多个任务

**执行所有待处理**:
- `/sdd/spec-impl $1` - 所有未选中的任务


