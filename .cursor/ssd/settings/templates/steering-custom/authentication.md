# 认证和授权标准

[目的：统一认证模型、令牌/会话生命周期、权限检查和安全性]

## 理念
- 清晰分离：认证（谁）vs授权（什么）
- 默认安全：最小权限，失败关闭，短期令牌
- 用户体验感知：高风险处有摩擦，其他处流畅

## 认证

### 方法（选择+理由）
- 选项: JWT、Session、OAuth2、混合
- 选择: [我们的方法] 因为 [原因]

### 流程（高级）
```
1) 用户证明身份（凭据或提供者）
2) 服务器验证并颁发令牌/会话
3) 客户端每个请求发送令牌
4) 服务器验证令牌并继续
```

### 令牌/会话生命周期
- 存储: httpOnly cookie或Authorization标头
- 过期: 短期访问，较长刷新（如使用）
- 刷新: 轮换令牌；尊重撤销
- 撤销: 在注销/泄露时列入黑名单/轮换

### 安全模式
- 强制TLS；在可避免时永远不要将令牌暴露给JS
- 将令牌绑定到受众/颁发者；包含最小声明
- 对于敏感操作，考虑设备绑定和IP/风险检查

## 授权

### 权限模型
- 选择一个: RBAC / ABAC / 基于所有权 / 混合
- 集中定义角色/属性；避免在代码库中硬编码

### 检查（在哪里强制执行）
- 路由/中间件: 粗粒度门控
- 领域/服务: 细粒度决策
- UI: 条件渲染（不依赖安全性）

示例模式:
```typescript
requirePermission('resource:action'); // route
if (!user.can('resource:action')) throw ForbiddenError(); // domain
```

### 所有权
- 模式: 所有者或特权角色可以操作
- 在实体边界上验证后再进行变更

## 密码和MFA
- 密码: 强策略，哈希（bcrypt/argon2），永远不纯文本
- 重置: 限时令牌，单次使用，通知用户
- MFA: 对风险操作升级（策略驱动）

## API到API认证
- 使用API密钥或OAuth客户端凭据
- 最小化密钥范围；轮换并审计使用
- 按身份（用户/密钥）限制速率

---
_关注模式和决策。无库特定代码。_
